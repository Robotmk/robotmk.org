---
draft: false
title: "RoboCon 2026 - Recap (Do, Konferenz Tag 1)"
# --- Italic subheading
# lead: 
# -- giscus id to match comments
commentid: robocon26-recap-2
# slug: 
# -- for posts in menubar, use this (shorter) title
# menutitle: 
description: null
date: "2026-02-14T10:04:33+02:00"
categories:
  - news
  - events
tags:
  - "robocon"
authorbox: true
sidebar: true
pager: false
thumbnail: "img/robocon.png"
vgwort: https://vg04.met.vgwort.de/na/c01978edca3a4e5b8ef7fa7757eb717e
---

Dies ist **Teil 2** der dreiteiligen Review der RoboCon 2026 in Helsinki.



<!--more-->

---

‚ûõ Zur√ºck zu **[Teil 1 (Dienstag/Mittwoch, Workshop & Community Day)]({{< ref "/robocon26-recap-1/" >}})**  
‚ûõ Weiter zu **[Teil 3 (Freitag: Konferenz Tag 2)]({{< ref "/robocon26-recap-3/" >}})**

---


![alt text](img/welcome.png)


## Donnerstag: Konferenz Tag 1

### Keynote: Community in the age of AI


{{< portrait src="img/miikka.png" alt="Miikka Solmela" >}}

**Miikka Solmela**, Executive Director der Robot Framework Foundation, er√∂ffnete die Konferenz und seine Keynote mit einer Frage: **Welchen Einfluss hat k√ºnstliche Intelligenz auf die Entwicklung der Community?**

Der Graph, den Miikka pr√§sentierte, war bedenklich: Die Zugriffe auf die Robot-Framework-Homepage gehen zur√ºck.  
Konkrete Daten aus Slack liegen zwar nicht vor ‚Äì doch die Vermutung liegt nahe, dass sich ein √§hnlicher Trend dort fortsetzt. 

Der Grund: Bevor es KI gab, suchten wir anders nach L√∂sungen - heute ist die "L√∂sung" nur noch einen Prompt entfernt. 
Es besteht die Gefahr, dass sich Menschen nicht mehr √ºber Probleme austauschen, sondern sich direkt an der KI bedienen. 

Doch das Arbeiten an einer Herausforderung geh√∂rt zum Lernprozess.  
Der Dialog mit anderen, das gemeinsame Ringen um L√∂sungen ‚Äì das formt Verst√§ndnis auf eine Weise, die eine unmittelbare KI-Antwort nicht leisten kann.

Miikka machte ausdr√ºcklich klar: Er wolle AI nicht verteufeln.  

Doch er mahnte zur Vorsicht. Wenn wir AI nicht weise einsetzen, riskieren wir, dass die Community, so wie wir sie heute kennen, nicht mehr fortbestehen wird. 
**Die Community ist der gr√∂√üte Schatz** ‚Äì und sie k√∂nnte unter unreflektiertem KI-Einsatz stark leiden.

Seine **Botschaft** war ein Aufruf zum bewussten Umgang: 

- AI als Werkzeug verstehen, nicht als Ersatz f√ºr den Austausch.  
- Bequemlichkeit darf nicht dazu f√ºhren, dass wir den Kontakt zur Community meiden. 
- Das Miteinander, das gegenseitige Lernen, Herausfordern und Unterst√ºtzen ist es, was das Robot-Framework-√ñkosystem stark macht.

üëâ **Fazit:**  
Eine Er√∂ffnung, die nachdenklich stimmte und den Ton f√ºr die Konferenz setzte: Technologie ist m√§chtig ‚Äì doch es ist an uns, sie so zu nutzen, dass sie verbindet, statt zu isolieren.

---


### The RoboCon Effect And The Power Of Contributing

**Gabriela Simion** und **Christoph Singer** (beide Imbus AG)

{{< portrait src="img/christoph.png" alt="Christoph Singer" >}}

{{< portrait src="img/gabriela.png" alt="Gabriela Simion" >}}

Die Pr√§sentation der beiden erz√§hlte eine Geschichte, die in der Robot-Framework-Community Resonanz gefunden haben d√ºrfte: **zwei Anwender werden zu Maintainern**.

**Gabriela Simion** und **Christoph Singer** beschrieben ihre pers√∂nliche Reise, wie der Besuch der RoboCon sie inspirierte, nicht nur Nutzer von Robot Framework zu bleiben, sondern aktive Contributor und schlie√ülich Maintainer der [AppiumLibrary](https://github.com/serhatbolsu/robotframework-appiumlibrary) zu werden (siehe Community Day).  

![alt text](img/talk-robocon-effect.png)

Im letzten Jahr haben sie das Ruder √ºbernommen und gerade **Version 3.0** der **AppiumLibrary** ver√∂ffentlicht.  


Die zentrale Botschaft war nicht neu. Aber sie ist immer noch dringend n√∂tig: Die RoboCon ist mehr als eine Serie von Pr√§sentationen.  
Sie ist ein Raum, in dem Menschen zusammenkommen, Ideen austauschen, neue Perspektiven entdecken, und **einander ermutigen, gr√∂√üer zu denken**.  
Das ist auch meine Erfahrung: Ich sehe die RoboCon als **Katalysator** f√ºr pers√∂nliche und berufliche Entwicklung, die wiederum auf das √ñkosystem von Robot Famework einzahlt.

Ein Kerngedanke der Pr√§sentation war die **Wichtigkeit individueller Beteiligung** ‚Äì die Idee, dass jeder, unabh√§ngig von Erfahrung oder Hintergrund, etwas Wertvolles zum √ñkosystem beitragen kann.  
Das erinnerte mich an Ed Manloves **"Law of 2 Feet"**: Bewege dich einfach zu den Orten, wo du lernen und beitragen kannst.  
Gabriela und Christoph verk√∂rpern dieses Prinzip perfekt.

**Gabriela erz√§hlte**, wie sie zu Beginn einen Library-Entwickler fragte: *"Wie viel Erfahrung als Python-Entwickler braucht es, Maintainer einer Library zu werden?"*  
Seine Antwort war pr√§gnant und ermutigend: *"Just start. Start small and learn by doing it."* 

**Christophs Weg** reichte weiter zur√ºck: 2019 sammelte er am Community Day der Robocon erste Erfahrungen in der Library-Entwicklung an der **WhiteLibrary** . Als er dann sp√§ter vor der Aufgabe stand, die AppiumLibrary mit den vielen offenen Issues auf Vordermann zu bringen, war er unsicher, ob er geeignet daf√ºr war. 
Doch Ed Manlove sprach ihm gut zu und machte neuen Mut.  
Ein subtiler, aber wichtiger Moment: **Die Community unterst√ºtzt sich selbst**.

Durch ihre Geschichte zeigten Gabriela und Christoph die **greifbaren Vorteile von Community-Engagement**: ein erweitertes Netzwerk, Verbesserung des technischen Verst√§ndnisses, √∂ffentliche Anerkennung, und nicht zuletzt das tiefe Gef√ºhl, Teil von etwas zu sein, das gr√∂√üer ist als man selbst.

Als sie gefragt wurden, wie es sich anf√ºhlte, das erste Release zu bauen, antworteten sie schlicht: 
> *"Nerv√∂s, aber unbeschreiblich... Man ist stolz, dass man hier nun seinen Namen stehen sieht."*   

Diese Antwort traf den Kern dessen, worum es in diesem Vortrag ging: **Beitragen bedeutet Zugeh√∂rigkeit.**

üëâ **Mein Fazit:** Der Vortrag war ein kraftvoller Reminder: Die echte St√§rke des Robot-Framework-√ñkosystems liegt nicht am Geldbeutel einzelner Firmen ‚Äì sie liegt in der **Zusammenarbeit**, dem gegenseitigen **Vertrauen** und der kollektiven Anstrengung der Community-Mitglieder.

---

### Let's play a game! 

{{< portrait src="img/yuri.png" alt="Yuri Verweij" >}}

Yuris Pr√§sentation stellte die interaktiven Elemente der Konferenz vor, die √ºber die **Gridaly Conference Companion App** organisiert wurden.  
Ziel war es, die Konferenz-Teilnehmer zur aktiven Beteiligung und zum Networking zu motivieren, √ºber ein gamifiziertes System mit Badges, Aufgaben und Robot-Stickern.  
Teilnehmer erledigen verschiedene Tasks (z.b. Besuch der Sponsor-St√§nde), um Belohnungen zu sammeln. Der Hauptpreis: ein Freiticket f√ºr die RoboCon 2027.  

Da ich dieses Jahr **Checkmk** als **Gold-Sponsor** vertreten durfte, kann ich best√§tigen: Die Gamification ist wirklich nicht zu untersch√§tzen.  
Sie bringt die Leute zueinander und l√§sst sie ins Gespr√§ch kommen. Ich hatte viele sehr gute fachliche Gespr√§che am Checkmk-Stand.

![alt text](img/booth.png)

---

### RF-MCP: Say It, Test It, Ship It

{{< portrait src="img/many.png" alt="Many Kasiriha" >}}

**Many Kasiriha** stellte in seiner Session sein Projekt ([RF-MCP](https://github.com/manykarim/rf-mcp)) vor ‚Äì eine L√∂sung f√ºr ein fundamentales Problem beim Einsatz von Large Language Models (LLMs) in der Testautomatisierung: deren Neigung zu "halluzinieren", also nicht existierende Keywords/Libraries zu erfinden oder logisch fehlerhafte Testschritte zu generieren.

**RF-MCP** erm√∂glicht es dem Benutzer, ein Testszenario in Prosa zu schreiben und am Ende Gegenzug ausf√ºhrbare Robot Framework-Tests zu erhalten.  
Dazwischen passiert etwas magisches: Jeder generierte Testschritt wird vom MCP-Server tats√§chlich mit Robot Frameowrk ausgef√ºhrt und verifiziert, bevor der finale Code entsteht.  
So wird sichergestellt, dass die KI ausschlie√ülich **validierte Keywords** verwendet, die auch tats√§chlich in den verf√ºgbaren Libraries und Resources des Projekts existieren -  und dass am Ende tats√§chlich lauff√§higer Automatisierungscode entsteht.  

RF-MCP unterst√ºtzt inzwischen die Keywords von 

- Browser Library + SeleniumLibrary
- AppiumLibrary
- RequestsLibrary
- DatabaseLibrary
- Django-basierte web frontends

üëâ **Fazit:**  
Ich bin zwar bisher niemandem begegnet, der den MCP-Server bereits produktiv zur Testerstellung nutzt.  
Doch das sollte eine Sache nicht verschleiern: **Many hat hier echte Pionierarbeit geleistet**, und dies ist erst der Anfang einer gro√üen Entwicklung, die nicht mehr aufzuhalten ist.   

Wer glaubt, KI werde "niemals" in der Lage sein, Tests so gut zu schreiben wie ein Mensch, wird in einigen Jahren vielleicht schon eines Besseren belehrt.

Nat√ºrlich frage auch ich mich, wohin das alles f√ºhren wird.  
Doch die besten Antworten auf solche Fragen findet man, indem man sich dem Thema mit offenem Geist n√§hert.  

Ganz einem Zitat von Wayne Dyer folgend: 

> *"If you change the way you look at things, the things you look at change."*

**Bleibt aufgeschlossen und neugierig!** üòâ

---

### Kann KI uns helfen, Bugs in Robot Framework schneller zu finden?

{{< portrait src="img/fabian.png" alt="Fabian Streitel" >}}

**Fabian Streitel** ber√§t seit √ºber zehn Jahren seine Kunden im Bereich der Testautomatisierung. Er pr√§sentierte einen faszinierenden Ansatz f√ºr ein Problem, das viele Teams mit gro√üen Testsuites kennen: Wie kann man **m√∂glichst schnelles Feedback** liefern, wenn die vollst√§ndige **Testausf√ºhrung Stunden oder gar Tage** dauert?

Die Kernidee seiner Pr√§sentation: statt die gesamte Testsuite zu durchlaufen, clustert man Tests und w√§hlt die zur Ausf√ºhrung aus, die in einem vektorbasierten Raum m√∂glichst weit voneinander entfernt sind - quasi ein "intelligenter Smoke-Test" üòâ  

![alt text](img/talk-3d.gif)

Auf diese Weise wird verhindert, dass die Testroutinen wiederholt redundante Pfade im Code durchlaufen, w√§hrend andere Bereiche noch ungetestet bleiben.

Fabian zeigte, wie er mittels sogenanntem **Mutation Testing** gezielt hunderte von Bugs in den Robot-Framework-Quellcode (als Testkaninchen) eingebracht hatte ‚Äì ein kontrollierbares Testszenario, um die Effektivit√§t seines Ansatzes zu beweisen.  


---

### Traceable Automation in Space Projects

{{< portrait src="img/bruno.png" alt="Bruno N√©stor Calvo Chevillat" >}}

{{< portrait src="img/jose.png" alt="Jos√© Mar√≠a Mart√≠n Bl√°zquez" >}}

Allein der Titel verfing schon bei mir! ü™ù üòÖ  

In einem hochregulierten Umfeld, wo jeder Fehler katastrophale Folgen haben kann, gelten Anforderungen an Testautomatisierung, die weit √ºber typische Web- oder App-Szenarien hinausgehen.

![alt text](img/talk-gmv.png)

Bruno und Jos√© zeigten, wie sie Robot Framework als zentrales Element ihrer Testautomatisierung etabliert haben, eng verzahnt mit Requirements-Management-Tools wie **IBM DOORS**.  

Die Herausforderung bestand darin, eine **bidirektionale Synchronisation** zwischen Anforderungsdefinitionen, Testprozeduren und deren Implementierung zu schaffen. So kann jeder einzelne automatisierte Testfall direkt auf eine spezifische Anforderung zur√ºckverfolgt werden ‚Äì eine **durchg√§ngige Kette der Nachvollziehbarkeit**, wie sie in derart sicherheitskritischen Systemen wie der Raumfahrt zwingend erforderlich ist.

Die Pr√§sentation beleuchtete dabei nicht nur die technische Integration, sondern auch die organisatorischen Konventionen, die in einem solchen Umfeld nat√ºrlich unverzichtbar sind.  
Gl√ºcklicherweise erf√ºllt Robot Framework die regulatorischen Standards und strikten Vorgaben der Luft- und Raumfahrtbranche f√ºr Dokumentation, Tagging und Reporting.  

Die Sprecher teilten auch offen ihre **Lessons Learned** ‚Äì von Fallstricken bis zu konkreten Empfehlungen f√ºr andere, die Automatisierung in regulierten oder sicherheitskritischen Industrien einf√ºhren m√∂chten. Es war deutlich zu sp√ºren, dass die beiden aus jahrelanger Erfahrung berichteten. 

üëâ **Fazit**: Der Vortrag machte klar, dass die Einfachheit und Erweiterbarkeit von Robot Framework keineswegs auf einfache Szenarien beschr√§nkt ist ‚Äì im Gegenteil.  
Mit der richtigen Disziplin und einem durchdachten Framework l√§sst sich mit Robot Framework auch in den anspruchsvollsten technischen Umgebungen eine robuste, nachvollziehbare Automatisierung aufbauen. Selten bekommt man Einblick in derart sensible, hochsichere Bereiche. 

---

### Keyword-Driven Performance Testing Without Manual Scripting

{{< portrait src="img/rakan.png" alt="Rakan Alrasheed" >}}

{{< portrait src="img/abdulelah.png" alt="Abdulelah Alharabi" >}}

Die beiden Sprecher pr√§sentierten eine innovative Architektur, die ein h√§ufig √ºbersehenes Problem adressiert: die Trennung zwischen funktionalen Tests und Performance-Tests. Ihr Ansatz eliminiert diese L√ºcke, indem er Robot Framework als **"Source of Truth"** f√ºr beide Testszenarien etabliert.

Die Kernidee: Funktionale Testszenarien, die bereits in Robot Framework definiert sind, werden automatisch in [Locust](https://locust.io)-Skripte √ºbersetzt ‚Äì ein leistungsstarkes, Python-basiertes Load-Testing-Tool.  
Was normalerweise manuelles Scripting und spezialisiertes Wissen erfordert, wird hier durch ein keyword-basiertes, intent-getriebenes System ersetzt.

Der Vortrag machte deutlich, dass die Wiederverwendbarkeit von Testdefinitionen ein oft untersch√§tzter Hebel ist.  
Wenn Teams ihre funktionalen Tests als Grundlage f√ºr Performance-Tests nutzen k√∂nnen, entsteht nicht nur Effizienz ‚Äì es entsteht auch eine engere Verzahnung zwischen Qualit√§tssicherung und Performance-Engineering - in modernen Entwicklungszyklen unverzichtbar.

---

### Automated Accessibility for "Very Busy" Teams


{{< portrait src="img/lalit.png" alt="Lalitkumar Bhamare" >}}

{{< portrait src="img/affaf.png" alt="Affaf Malik" >}}

**√úber 90%** (!) der eine Million meistbesuchten Websites weisen **Accessibility-Probleme** auf.  
Das stellt nicht nur ein technisches, sondern auch ein gesch√§ftliches, rechtliches und ethisches Problem dar: Nutzer, die auf assistive Technologien angewiesen sind, sto√üen t√§glich auf Barrieren.   

Das liegt nicht einmal daran, dass Teams das Thema "Accessibility" unbedingt ignorieren wollen. Sondern weil sie schlicht nicht die Kapazit√§t, das Budget oder auch manchmal das spezialisierte Wissen haben, um umfassende manuelle Tests daf√ºr durchzuf√ºhren.

Affaf und Lalitkumar zeigten eine **"Shift-Left"-Strategie** auf (wobei "left" = "fr√ºher"), die Accessibility-Testing **ganz vorn** im Entwicklungszyklus verankert.  
In ihrem Ansatz gliedert sich das in drei Ebenen:

- Auf **Entwicklungsebene** k√∂nnen Probleme bereits erkannt werden, bevor √ºberhaupt automatisierte Tests geschrieben werden. Verst√∂√üe wie etwa fehlende "alt"-Texte oder inkorrekte ARIA-Attribute k√∂nnen die Entwickler direkt beim Coding erkennen und korrigieren. 
- Auf **Testebene** integriert Robot Framework Tools wie [axe-core](https://github.com/dequelabs/axe-core) und  nahtlos in funktionale und Regressionstests. Accessibility-Checks sollen damit Teil des t√§glichen Testings werden ‚Äì ohne zus√§tzlichen manuellen Aufwand.
- Auf **Prozessebene** werden die Tests in CI/CD-Pipelines eingebunden. Erkannte Issues k√∂nnen automatisch getrackt und mit Development-Tasks verkn√ºpft werden, sodass kontinuierliche Validierung stattfindet und Regressionen vor dem Deployment verhindert werden.

Die zentrale Botschaft der Session war klar: Accessibility-Automatisierung ist nicht nur ein Werkzeug zum Aufsp√ºren von Verst√∂√üen ‚Äì sie verdient ein **nachhaltiges System**, in dem Technologie aktiv Diversit√§t und Nutzbarkeit unterst√ºtzt.  

Aber auch die Kehrseite beleuchteten die beiden: "*accessibility can backfire*", wenn sie falsch implementiert wird oder wenn automatisierte Checks ein falsches Sicherheitsgef√ºhl vermitteln, ohne die tats√§chliche Nutzererfahrung zu ber√ºcksichtigen.  
Allzu leichtfertig wird das Thema n√§mlich einfach nur abgehakt - und Jahre sp√§ter kann sich kaum einmal mehr jemand an die Rahmenbedingungen erinnern. 

---

### Automation with Image Recognition Libraries

{{< portrait src="img/Helio2.png" alt="H√©lio Guilherme" >}}

**H√©lio Guilherme** ist eine Koryph√§e auf dem Gebiet der bildbasierten Testautomation. Seit 2008 schon arbeitet er mit Robot Framework ‚Äì zun√§chst bei Nokia Networks in Lissabon ‚Äì und ist heute Lead Developer und Maintainer der Robot Framework-IDE [RIDE](https://github.com/robotframework/RIDE/) sowie Maintainer der [SikuliLibrary](https://marketsquare.github.io/robotframework-SikuliLibrary/).  
Mit einem Augenzwinkern beschreibt er sich selbst als jemanden, der nicht wei√ü, ob er "*ein Software Tester ist, der gerne Software Development macht, oder ein Software Developer, der gerne Software Testing macht*". üòâ

Seine Session bot eine fundierte **vergleichende Analyse** zweier prominenter Image-Recognition-Libraries f√ºr Robot Framework: **SikuliLibrary** und **ImageHorizonLibrary**.  
Diese Libraries sind bei Desktop-Tests unverzichtbar, wenn API-basierte Technologien nicht verf√ºgbar sind ‚Äì etwa bei Legacy-UIs oder RDP/Citrix-Verbindungen.

![alt text](img/talk-helio.png)

#### Sikuli

[SikuliLibrary](https://github.com/MarketSquare/robotframework-SikuliLibrary) basiert auf dem Java-Framework SikuliX und nutzt [Robot Framework Remote](https://github.com/robotframework/RemoteInterface), um Python-Funktionen mit den Java-Libraries zu verbinden.  
Ein wesentlicher Vorteil: Sie bietet **Optical Character Recognition (OCR)** ‚Äì Texterkennung direkt aus Bildern.  

Der Workflow: Library importieren, *Server starten*, Pfad zu Referenzbildern definieren, Application Under Test (AUT) starten, Interaktionen durchf√ºhren (Maus, Tastatur, Bildabgleich, OCR), *Server stoppen*.  
Mit **78 Keywords** ist sie √ºppig ausgestattet. Der Haken: Man ben√∂tigt eine Java Runtime Environment im System. 

#### ImageHorizonLibrary

Die [ImageHorizonLibrary](https://github.com/eficode/robotframework-imagehorizonlibrary) hingegen setzt auf native Python-Module wie `pyautogui` und optional `opencv-python` f√ºr pr√§zisere Bilderkennung (erlaubt dann auch einen prozentualen "Similarity"-Wert).  
Sie ist schlanker ‚Äì **34 Keywords** ‚Äì und verzichtet auf OCR-Funktionalit√§t.  
Der gro√üe Vorteil: Kein Java-Overhead, direkter Einsatz m√∂glich. Der Workflow √§hnelt dem der SikuliLibrary, nur ohne Server-Komponente.

#### Vergleich 

Beide Libraries sind **betriebssystemunabh√§ngig**, erfordern aber konsistente Bildschirmaufl√∂sungen f√ºr reproduzierbare Tests.  

> *Anmerkung aus meiner Erfahrung: das prim√§re Problem bei der Bilderkennung ist nicht die **Aufl√∂sung**. Ein 80x30 Pixel gro√üer Button hat diese Abmessungen auf einem 800x600px Display wie auf einem 4K-Display - es bleiben 80x30 Pixel.  
Viel mehr Einfluss auf die Teststabilit√§t hat, wie die Anwendung ihr **Layout unter verschiedenen Aufl√∂sungen**, oder sagen wir besser, Platzbedingungen, √§ndert.  
Denn dann kann es sein, dass z.b. bestimmte Navigationselemente aus Platzgr√ºnden verborgen werden.*

H√©lio betonte, dass die Wahl der Library vom konkreten Use Case abh√§ngt: Braucht man Texterkennung aus Screenshots? Dann SikuliLibrary. Geht es um schlanke, rein Python-basierte Bildvergleiche? Dann ImageHorizonLibrary.

Ein kritischer Punkt, den H√©lio ansprach: Die **Zukunft der SikuliLibrary** h√§ngt vom zugrunde liegenden SikuliX-Projekt ab, dessen Maintainer die Entwicklung pausiert hat.  
Auch die vollst√§ndig in Python integrierte Version **sikulix4python**, die Autor Raimund Hocke entwickeln wollte, ist leider versandet. 

üëâ **Fazit**  
Was mich besonders freute: Am Dienstag durfte ich **Jhoiss Baloi** kennenlernen, der die nicht mehr gewartete ImageHorizonLibrary **geforkt** und inzwischen auch **weiterentwickelt** hat.  
Er hat sogar meinen [Pull Request f√ºr Edge Detection](https://www.robotmk.org/en/blog/imagehorizon-edgedetection/) integriert und angek√ºndigt, die Library unter neuem Namen zu ver√∂ffentlichen.  
Das ist eine gro√üartige Nachricht f√ºr alle, die auf diese schlanke, Python-basierte L√∂sung setzen!  
Mir pers√∂nlich ist der Java-Unterbau der SikuliLibrary zu umfangreich, daher bin ich sehr froh √ºber diese Entwicklung.


---

### Integrating Robot Framework in your business strategy

{{< portrait src="img/markus.png" alt="Markus Stahl" >}}

Markus Stahls Vortrag adressierte Herausforderungen, die viele Unternehmen kennen: 

- Wie l√§sst sich ein Open-Source-Tool wie Robot Framework in klassische Evaluierungsprozesse in Firmen integrieren?
- Vor allem, wenn es keine Firma dahinter gibt, die Enterprise-Support anbietet? 
- Wie mitigiert man die Risiken der Adoption eines freien Tools, dessen √ñkosystem auf einer Vielzahl ebenfalls freier Projekte basiert?

Markus zeigte einen **f√ºnfstufigen Plan**, der Unternehmen zeigt, wie sie Robot Framework nicht nur nutzen, sondern strategisch in ihr Gesch√§ftsmodell integrieren k√∂nnen ‚Äì und dabei gleichzeitig zum eigenen direkten Vorteil zum √ñkosystem beitragen.

**Schritt 1: Das Projekt finanzieren (Fund it)**  

Oft schon sehr fr√ºh stellt sich die Frage: *Wer bezahlt eigentlich f√ºr die Wartung und Weiterentwicklung von Robot Framework?*  
Markus erkl√§rte, wie die [Robot Framework Foundation](https://robotframework.org/foundation/) arbeitet und wohin das Geld investiert wird ‚Äì etwa zwei Drittel der Kosten f√ºr die Konferenz werden durch die Foundation getragen, der Rest durch die Tickets.  
Die Herausforderung: Unternehmen von einer Mitgliedschaft zu √ºberzeugen ist nicht trivial. Traditionelle Mehrwerte wie SLAs oder Premium-Support fehlen. Zudem wird die Roadmap von der Community und dem Projektzweck definiert, nicht von zahlenden Mitgliedern. Das verstehen nicht alle "Entscheider".

**Schritt 2: Ein Tool/eine Erweiterung beisteuern (Contribute a Tool/Extension)**  

Irgendwann kommt der Punkt, an dem man selbst eine Erweiterung programmiert.  
Unternehmen k√∂nnen n√ºtzliche Tools, die sie f√ºr sich entwickelt haben, als Open Source ver√∂ffentlichen ‚Äì prominente Beispiele sind [PlatynUI](https://github.com/imbus/platynui-sut), [RoboSAPiens](https://github.com/imbus/robotframework-robosapiens) oder [KeyTA](https://pypi.org/project/robotframework-keyta/1.0.10/).  
Das Risiko: Wenn mittel- und langfristig keine externen Contributors gefunden werden, muss das Unternehmen dauerhaft Ressourcen f√ºr ein Nicht-Kerngesch√§ft-Projekt binden. Beratungsunternehmen haben hier tendenziell einen gr√∂√üeren Anreiz.

**Schritt 3: Ein Feature beisteuern (Contribute a Feature)**  

Statt ein ganzes Tool zu entwickeln, kann man auch gezielt fehlende Funktionen in den RF-Core implementieren und als Pull Request einreichen.  
Ein Beispiel: Die **Deutsche Flugsicherung** hat das RobotFramework-Feature [custom test metadata](https://github.com/robotframework/robotframework/issues/4409) bezahlt und implementieren lassen.  
Solche Projekte eignen sich auch hervorragend zur Nachwuchsf√∂rderung ‚Äì Junior-Entwickler sammeln wertvolle Erfahrungen mit Open Source.

**Schritt 4: Support anbieten (Offer Support)**  

Unternehmen k√∂nnen professionellen Support f√ºr Open-Source-Tools anbieten, von denen sie oder ihre Kunden abh√§ngig sind.  
Die Leistungen k√∂nnen Tool-Mirroring und die Bereitstellung von Notfall-Fixes im Rahmen von SLAs umfassen.  
Diese Fixes sollten anschlie√üend als Beitrag in das urspr√ºngliche Projekt zur√ºckflie√üen.  
Markus betonte, dass hier die neuen Verordnungen wie **DORA** und **CRA** ber√ºcksichtigt werden sollten.

**Schritt 5: Offen dar√ºber sein (Be open about it)**  

Der letzte, oft untersch√§tzte Schritt: **Offen kommunizieren**, dass man Open Source nutzt und unterst√ºtzt.  
Stolz auf die eigene Beteiligung zu sein, inspiriert andere und st√§rkt das √ñkosystem.

Markus nutzte die Aufmerksamkeit am Ende seines Vortrags, um eine **neue Open-Source-Governance-Arbeitsgruppe** zu promoten, die die Expertise der Community sammeln und Empfehlungen f√ºr Robot Framework und √ñkosystem-Projekte etablieren soll.

üëâ **Fazit**  
Der Vortrag war eine **inspirierende Ermutigung** f√ºr alle, die ihren Arbeitgeber √ºberzeugen m√∂chten, mehr in Open Source zu investieren. Mit konkreten, praktikablen Wegen, wie das geschehen kann.  
Die Botschaft war klar: Es gibt mehr M√∂glichkeiten als nur "Sponsorship" oder "Freizeit opfern".

---

### Medusa: Resource-aware parallel suite execution made easy

**Edin Tariƒá**

Edins Session adressierte ein Problem, das viele Teams mit umfangreichen Testsuites kennen: **Wie parallelisiert man Tests effektiv, wenn Ressourcen-Konflikte drohen?**

**INSYS** ist Hersteller industrielle Router, deren Software tagt√§glich auf den Devices getestet wird ‚Äì **1500 Tests**, die sequenziell ausgef√ºhrt **bis zu 60 Stunden** dauern w√ºrden!  
Ein unhaltbarer Zustand bei t√§glichen Build-Inkrementen.  
Hier denkt man nat√ºrlich gleich an Parallelisierung mit [pabot](https://pabot.org/). Doch hier stie√ü das Team schnell an Grenzen.

![alt text](img/talk-medusa.png)

Das **Problem**: Viele der Testsuites ben√∂tigen n√§mlich exklusiven Zugriff auf spezifische Ressourcen ‚Äì etwa ein bestimmtes Ger√§t im Netzwerk, einen bestimmten Port oder physische Ressourcen wie DSL-Verbindungen, die nicht mehrfach parallel genutzt werden k√∂nnen.  
Pabot mit manuell geschriebenen Ordering-Files wurde bei √ºber 1000 Tests schnell un√ºbersichtlich und ineffizient.  
Versuche, die Ordering-Datei zu automatisieren, scheiterten: Dynamisches Vermeiden von Ressourcen-Konflikten ist schlicht nicht das, wof√ºr pabot designed wurde.

**Medusa** wurde explizit um die Idee von **Ressourcen-Abh√§ngigkeiten** herum entwickelt.  

Jede Suite deklariert ihre Ressourcen-Abh√§ngigkeiten als **Metadaten**, und Medusa bestimmt zur Laufzeit automatisch, welche Suites parallel starten k√∂nnen ‚Äì das maximiert die Zeiteffizienz und vermeidet Konflikte.

Zus√§tzlich zu den Dependencies wird jede Suite einer **Stage** zugewiesen: Stages sind **sequenziell ausgef√ºhrte Gruppen**, innerhalb derer die Suites wie beschrieben parallel laufen.  
So beh√§lt man die n√∂tige Kontrolle √ºber die Reihenfolge, wo es darauf ankommt.

Suites k√∂nnen mehrfach auch mit **unterschiedlichen Variablen** ausgef√ºhrt werden ‚Äì sogar mit unterschiedlichen Dependencies oder Stages.  
Das reduziert Code-Duplikation erheblich, wenn man eine Suite f√ºr mehrere Targets oder Varianten nutzen m√∂chte.

Technisch funktioniert Medusa also als **Wrapper** um Robot Framework: Nahezu alle Robot-Optionen werden akzeptiert und an die Prozesse weitergereicht, die die einzelnen Suites ausf√ºhren.  
Das bedeutet: **Listener, Pre-Run-Modifiers** und andere Erweiterungen allesamt bleiben nutzbar.  
Am Ende nutzt Medusa `rebot`, um die Ergebnisse aller Suites nahtlos zusammenzuf√ºhren ‚Äì selbst bei massiver Parallelisierung.

üëâ **Fazit**:  

Perfect Timing, Medusa wurde rechtzeitig vor der RoboCon 2026 als Open Source ver√∂ffentlicht.  
F√ºr alle, die mit gro√üen Testsuites und Ressourcen-Konflikten k√§mpfen, k√∂nnte Medusa genau die L√∂sung sein, auf die sie gewartet haben.  
Ein pragmatischer Ansatz, der ein echtes Problem mit einer durchdachten L√∂sung gut adressiert. Ich fand das System sofort eing√§ngig. 

---

### From Batter to Better: Pancakes as Testing

{{< portrait src="img/kelby.png" alt="Kelby Stine" >}}

{{< portrait src="img/elout.png" alt="Elout van Leeuwen" >}}

**Kelby Stine** und **Elout van Leeuwen** pr√§sentierten eine der unterhaltsamsten Sessions der RoboCon 2026.  **Pfannkuchenbacken als Metapher f√ºr Testautomatisierung** ‚Äì und machten damit abstrakte Konzepte auf erfrischende Weise greifbar.

Die B√ºhne war entsprechend vorbereitet: Ein Tisch mit Herdplatte, Pfanne, Zutaten ‚Äì und beide Sprecher in Kochsch√ºrzen.  

Raunen im Publikum. 

*Was wird hier gleich passieren?*

![alt text](img/talk-pancakes.png)

Die Pr√§sentation begann mit einem simplen Bekenntnis: 

Beide lieben **Pfannkuchen**.  

Und dann machten sie sich daran, die Teige daf√ºr mit **zwei verschiedenen Rezepturen** zuzubereiten ‚Äì jeder auf seine eigene Art.  
Die unterschiedlichen Zubereitungsweisen wurden parallel als **Robot-Framework-Pseudocode** auf der Leinwand dargestellt.  
Ein brillanter visueller Einfall, der die Parallelen deutlich machte.

> *Netherlands üá≥üá± meets the US üá∫üá∏ ... Ich pers√∂nlich war ja  mehr Fan von Elouts schlichtem Rezept ‚Äì bis auf die ganze Hand voller Salz, die er theatralisch im Scheinwerferlicht staubend in den Teig schmiss üòÖ.  
Aber das war nat√ºrlich Teil der Show, denn auf der B√ºhne durfte aus Sicherheitsgr√ºnden ohnehin nicht tats√§chlich gekocht werden, der Teig diente rein der Demonstration.*

Die **Kernidee** der Session: Es gibt strukturelle **Analogien** zwischen Kochrezepten und dem Keyword-Driven Ansatz von Robot Framework. Die Keywords beschrieben abstrakt, was zu tun ist, und kapseln die ganzen Details, um die man sich als Tester/Pfannkuchenkoch nicht explizit k√ºmmert.  

Sowohl beim Kochen als auch beim Testen sind **Zutaten** (Ingredients), **Umgebung** (Environment), **Setup** und **Arbeitsschritte** (cooking steps) zentral.  

Beide betonten: *"Make sure variables are OK. Otherwise it will break."* ‚Äì eine Aussage, die nat√ºrlich f√ºr Teig wie f√ºr Code gleicherma√üen gilt.  
(Gerade erst heute habe ich wieder selbst Brot gebacken und musste beim Teig kneten daran denken üòâ)

Ein weiteres sch√∂nes Detail: **Pfannkuchen gibt es √ºberall auf der Welt** ‚Äì das repr√§sentiert die internationale Community.  
Es gibt kein Pfannkuchen-Rezept, das besser ist als ein anderes ‚Äì genau wie es in der Automatisierung keine L√∂sung gibt, die f√ºr alle Szenarien die beste ist.  

Auch das **Toolset** variiert: Manche setzen auf Parallelisierung ‚Äì visualisiert durch eine gro√üe Kochplatte mit vielen Pfannen.  
Andere bevorzugen sequenzielle Abl√§ufe.  
Beides ist legitim, beides hat seinen Platz.

Dann zuletzt die Behandlung des Themas **Reporting**:  
*"HOW WOULD YOU LIKE YOUR TEST RESULTS SERVED?"*  
Auf der Leinwand erschienen verschiedene Anrichtvarianten von Pfannkuchen: mit Puderzucker, mit Sirup, mit Fr√ºchten, gestapelt oder einzeln.  
Die Botschaft war klar: Testergebnisse k√∂nnen auf viele verschiedene Arten aufbereitet und pr√§sentiert werden ‚Äì je nach Zielgruppe und Zweck.

Besonders witzig wurde es am Ende, als Fragen aus dem Publikum kamen - man merkte, wie sich die Fragen gegenseitig √ºberboten:  

*"...When are you taking it to production?"*  
*"...Do you need acceptance testers?"*  

Und dann setzte **Ren√© Rohner** noch einen drauf: Er untersuchte kritisch den Tisch und meinte dann trocken:  

*"But it does not seem to be open source ‚Äì there is no **fork**."*  üòÖ


**Fazit:**  
Das Ganze war kurzweilig, unterhaltsam und gleichzeitig lehrreich.  
Die Session stellte heraus, was der **Mehrwert von Robot Framework ist**: N√§mlich, dass es die Komplexit√§t von Python abstrahiert und in eine **menschenlesbare Sprache** √ºbersetzt.  

Eine wunderbare Art, ernste Konzepte mit Leichtigkeit zu vermitteln.


---

‚ûõ Zur√ºck zu [Teil 1 (Dienstag/Mittwoch, Workshop & Community Day)]({{< ref "/robocon26-recap-1/" >}})  
‚ûõ Weiter zu [Teil 3 (Freitag: Konferenz Tag 2)]({{< ref "/robocon26-recap-3/" >}})
